// В данном примере Animal - это родительский класс, а Dog и Cat - дочерние классы. Оба дочерних класса переопределяют метод makeSound из родительского класса.
// При создании объектов Dog и Cat как Animal, мы можем вызвать метод makeSound для объектов разных классов через общий интерфейс, предоставляемый родительским классом.

// Преимущества полиморфизма:

// Универсальность кода: Код может быть написан более универсально, так что методы могут работать с объектами разных классов, поддерживающих общий интерфейс.
// Улучшенная читаемость: Использование полиморфизма может улучшить читаемость кода и сделать его более понятным.
// Расширяемость: Добавление новых классов, реализующих общий интерфейс, легко расширяет функциональность программы без изменения существующего кода.

// Недостатки полиморфизма:

// Оверхед: Иногда использование полиморфизма может привести к некоторому оверхеду из-за необходимости определения общего интерфейса и динамического вызова методов.
// Сложность отладки: В некоторых случаях полиморфизм может усложнить отладку, особенно если классы имеют сложные взаимосвязи.

// В целом, правильное использование полиморфизма может значительно улучшить структуру кода и сделать его более гибким.

// Родительский класс
class Animal {
    public void makeSound() {
        System.out.println("Some generic sound");
    }
}

// Дочерний класс, наследующий от Animal
class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Woof! Woof!");
    }

    public void fetch() {
        System.out.println("Fetching the ball");
    }
}

// Другой дочерний класс, также наследующий от Animal
class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Meow!");
    }

    public void climb() {
        System.out.println("Climbing a tree");
    }
}

public class PolymorphismExample {
    public static void main(String[] args) {
        // Использование полиморфизма
        Animal myDog = new Dog();
        Animal myCat = new Cat();

        // Вызов переопределенного метода makeSound для объектов разных классов
        myDog.makeSound();  // Вывод: "Woof! Woof!"
        myCat.makeSound();  // Вывод: "Meow!"

        // Ошибка компиляции, так как метод fetch не определен в классе Animal
        // myDog.fetch();

        // Ошибка компиляции, так как метод climb не определен в классе Animal
        // myCat.climb();
    }
}
